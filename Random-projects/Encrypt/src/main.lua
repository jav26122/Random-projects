---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by jaret.
--- DateTime: 1/19/19 1:34 PM
---

-- Limit function:  ( 94 / (1+e^(-x/200)) ) + 32

function Sigmoid(input)
    local sg = (94 / (1 + math.pow(2.71828182845904523536, (input*-1) / 200))) + 32
    return math.floor(sg), sg
end


function toByte(s) -- Literally just gets the ascii value of a character
    r = string.byte(s)
    return r
end

function tablechars(s) -- puts all characters in a string into a table....kind of a c-string
    t={}
    for i=1, string.len(s) do
        table.insert(t, string.sub(s, i, i))
    end
    return t
end

function toDecimal(bits) --converts binary to decimal
    sum=0
    local bits = string.reverse(bits)
    for i = 1, string.len(bits) do
        num = string.sub(bits, i,i) == "1" and 1 or 0
        sum = sum + num * math.pow(2, i-1)
    end
    return sum
end

function toBits(s, bits) -- converts to the binary equivalent of the ascii value for a character
    b = ""
    l = string.len(s)
    for i=1, l do
        ascii = toByte(string.sub(s, l - i + 1, l - i + 1))
        q = ascii
        while q > 0 do
            if q % 2 == 1 then
                b = "1"..b
            else
                b = "0"..b
            end
            q = math.floor(q/2)
        end
       -- b = " "..b
    end
    if string.len(b) < bits then
        for i=1, (math.abs(string.len(b) - bits)) do
            b = "0"..b
        end
    end
    return b
end

function flip(b) -- flips any string Alternatively string.reverse() exists
    s = ""
    for i=1, string.len(b) do
        s = string.sub(b, i, i)..s
    end
    return s
end

--[[
for i=32, 126 do
    tob = toBits(string.char(i), 8)
    flipb = flip(tob)
    print("Start num:"..i.." Character: "..string.char(i).." Bits: "..tob.." Flipped Bits: "..flipb.." Decimal flipped: "..toDecimal( flipb) )
    print("Sigmoid: "..Sigmoid(toDecimal(flipb)))
end
]]

key = "testKy"

string1="asdf"

function Encrypt(original, key)
    div = math.floor(string.len(original) / string.len(key))
    rem = string.len(original) / string.len(key) - div
    mod = string.len(original)%string.len(key)
    result = ""
    if div < 1 then -- the key is longer than string
        for i=1, mod do
            keychar = string.sub(key, i, i)
            orgchar = string.sub(original, i, i)
            keyb = toBits(keychar, 8)
            orgb = toBits(orgchar, 8)
            flippedkey = toDecimal(flip(keyb))
            flippedorg = toDecimal(flip(orgb))
            avg = (flippedkey + flippedorg) / 2
            print(keychar)
            print(orgchar)
            print(flippedkey)
            print(flippedorg)
            print(avg)
            char = string.char(Sigmoid(avg))
            result = result..char
        end
    end
    return result
end


print(Encrypt(string1, key))



